# Basic Operations and Control Flow
1. Write a program to find the factorial of a number without using recursion
2. Create a program to check if a number is a palindrome
3. Write a program to find the sum of digits of a number
4. Generate the first n numbers of the Fibonacci sequence
5. Check if a number is prime
6. Print all prime numbers in a given range
7. Find the GCD of two numbers
8. Calculate the LCM of two numbers
9. Convert decimal to binary without using bin()
10. Generate all possible combinations of a string

# String Manipulation
11. Reverse a string without using string slicing
12. Check if a string is an anagram of another string
13. Find the first non-repeated character in a string
14. Count the occurrence of each character in a string
15. Remove all duplicates from a string
16. Check if a string contains only digits
17. Find the longest palindromic substring
18. Implement string compression (e.g., 'AABBC' â†’ 'A2B2C1')
19. Check if two strings are rotations of each other
20. Find all permutations of a string

# Lists and Arrays
21. Find the second largest number in a list
22. Rotate an array by k positions
23. Find pairs in an array with a given sum
24. Merge two sorted arrays
25. Find the missing number in an array of 1 to N
26. Find the intersection of two arrays
27. Move all zeros to the end of an array
28. Find the maximum subarray sum (Kadane's Algorithm)
29. Find duplicate elements in an array
30. Sort an array of 0s, 1s, and 2s (Dutch National Flag problem)

# Matrix Operations
31. Transpose a matrix
32. Rotate a matrix by 90 degrees
33. Search in a sorted 2D matrix
34. Print a matrix in spiral form
35. Find the sum of diagonal elements
36. Check if a matrix is symmetric
37. Multiply two matrices
38. Find the determinant of a matrix
39. Convert matrix to zigzag form
40. Find the saddle point in a matrix

# Dictionary and Sets
41. Find the frequency of elements in a list using dictionary
42. Implement a dictionary with default values
43. Sort a dictionary by values
44. Find common elements in three sorted arrays
45. Implement a function to return top k frequent elements
46. Group anagrams together
47. Check if two arrays are disjoint
48. Find the longest consecutive sequence
49. Implement LRU Cache
50. Find symmetric pairs in an array

# Linked Lists
51. Reverse a linked list
52. Find the middle element of a linked list
53. Detect a cycle in a linked list
54. Remove duplicates from a sorted linked list
55. Merge two sorted linked lists
56. Check if a linked list is palindrome
57. Add two numbers represented by linked lists
58. Sort a linked list
59. Clone a linked list with random pointers
60. Remove nth node from end of list

# Stack and Queue
61. Implement stack using queues
62. Implement queue using stacks
63. Check for balanced parentheses
64. Evaluate postfix expression
65. Implement min stack
66. Implement stack with getMin() in O(1)
67. Sort a stack using recursion
68. Implement circular queue
69. Find next greater element
70. Design a stack that supports getMin(), push(), pop() in O(1)

# Trees and Binary Search Trees
71. Find height of binary tree
72. Print level order traversal
73. Check if a binary tree is BST
74. Find lowest common ancestor
75. Convert binary tree to mirror tree
76. Print all paths from root to leaf
77. Find diameter of binary tree
78. Construct tree from inorder and preorder
79. Check if two trees are identical
80. Print boundary nodes of binary tree

# Graph Problems
81. Implement BFS
82. Implement DFS
83. Find shortest path in unweighted graph
84. Detect cycle in directed graph
85. Topological sort
86. Find number of islands
87. Check if graph is bipartite
88. Find strongly connected components
89. Implement Dijkstra's algorithm
90. Find minimum spanning tree

# Advanced Problems
91. Implement a basic regex parser
92. Create a memory efficient doubly linked list
93. Implement rainwater trapping problem
94. Find median in a stream of integers
95. Implement thread-safe singleton pattern
96. Design a URL shortener
97. Implement producer-consumer problem
98. Create a basic calculator
99. Design a parking lot system
100. Implement a basic file system

# Practice Tips
- Try to solve each problem without looking at solutions first
- Focus on writing clean, efficient code
- Consider edge cases in your solutions
- Try to optimize your initial solutions
- Practice time complexity analysis for each solution
- Write test cases before implementing
- Try different approaches to solve the same problem
